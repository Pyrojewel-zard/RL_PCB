# 10. 评估阶段

## 概述
评估阶段负责对训练好的模型进行性能测试，通过多个episode的评估来量化模型在PCB布局优化任务上的表现，并生成详细的评估报告。

## 详细流程

### 10.1 评估阶段启动

#### 10.1.1 评估函数调用
```python
def evaluate_model(self, model, env, num_episodes=16, deterministic=True):
    """评估模型性能"""
    print(f"Starting evaluation phase with {num_episodes} episodes...")
    
    # 初始化评估统计
    evaluation_stats = {
        'episodes': [],
        'total_rewards': [],
        'episode_lengths': [],
        'final_positions': [],
        'wirelengths': [],
        'overlaps': [],
        'hpwl_scores': []
    }
    
    # 执行评估episodes
    for episode in range(num_episodes):
        episode_result = self._evaluate_episode(model, env, episode, deterministic)
        evaluation_stats['episodes'].append(episode_result)
        
        # 收集统计信息
        evaluation_stats['total_rewards'].append(episode_result['total_reward'])
        evaluation_stats['episode_lengths'].append(episode_result['episode_length'])
        evaluation_stats['final_positions'].append(episode_result['final_positions'])
        evaluation_stats['wirelengths'].append(episode_result['wirelength'])
        evaluation_stats['overlaps'].append(episode_result['overlap'])
        evaluation_stats['hpwl_scores'].append(episode_result['hpwl_score'])
        
        # 输出episode结果
        print(f"Episode {episode}: Reward={episode_result['total_reward']:.3f}, "
              f"Length={episode_result['episode_length']}, "
              f"Wirelength={episode_result['wirelength']:.2f}, "
              f"HPWL={episode_result['hpwl_score']:.2f}")
    
    # 计算总体统计
    overall_stats = self._calculate_overall_stats(evaluation_stats)
    
    print(f"Evaluation completed. Mean reward: {overall_stats['mean_reward']:.3f}")
    return evaluation_stats, overall_stats
```

### 10.2 单Episode评估

#### 10.2.1 Episode评估函数
```python
def _evaluate_episode(self, model, env, episode_num, deterministic):
    """评估单个episode"""
    # 重置环境
    obs = env.reset()
    episode_reward = 0
    episode_length = 0
    episode_actions = []
    episode_positions = []
    
    # 记录初始状态
    initial_positions = self._get_all_component_positions(env)
    episode_positions.append(initial_positions)
    
    while True:
        # 获取模型动作
        if deterministic:
            action, _ = model.predict(obs, deterministic=True)
        else:
            action, _ = model.predict(obs, deterministic=False)
        
        # 执行动作
        obs, reward, done, info = env.step(action)
        
        # 记录episode信息
        episode_reward += reward
        episode_length += 1
        episode_actions.append(action)
        
        # 记录组件位置
        current_positions = self._get_all_component_positions(env)
        episode_positions.append(current_positions)
        
        if done:
            break
    
    # 计算最终指标
    final_positions = episode_positions[-1]
    wirelength = self._calculate_total_wirelength(env)
    overlap = self._calculate_total_overlap(env)
    hpwl_score = self._calculate_hpwl_score(env)
    
    return {
        'episode_num': episode_num,
        'total_reward': episode_reward,
        'episode_length': episode_length,
        'episode_actions': episode_actions,
        'episode_positions': episode_positions,
        'final_positions': final_positions,
        'wirelength': wirelength,
        'overlap': overlap,
        'hpwl_score': hpwl_score,
        'initial_positions': initial_positions
    }
```

### 10.3 性能指标计算

#### 10.3.1 线长计算
```python
def _calculate_total_wirelength(self, env):
    """计算总线长"""
    total_wirelength = 0.0
    
    # 遍历所有边（连接）
    for edge in env.g.get_edges():
        # 获取连接的两个组件
        node1_id = edge.get_instance_id(0)
        node2_id = edge.get_instance_id(1)
        
        node1 = env.g.get_node_by_id(node1_id)
        node2 = env.g.get_node_by_id(node2_id)
        
        # 计算曼哈顿距离
        pos1 = node1.get_pos()
        pos2 = node2.get_pos()
        
        wirelength = abs(pos1[0] - pos2[0]) + abs(pos1[1] - pos2[1])
        total_wirelength += wirelength
    
    return total_wirelength
```

#### 10.3.2 重叠计算
```python
def _calculate_total_overlap(self, env):
    """计算总重叠面积"""
    total_overlap = 0.0
    components = env.g.get_nodes()
    
    # 检查所有组件对之间的重叠
    for i in range(len(components)):
        for j in range(i + 1, len(components)):
            comp1 = components[i]
            comp2 = components[j]
            
            overlap_area = self._calculate_component_overlap(comp1, comp2)
            total_overlap += overlap_area
    
    return total_overlap
```

#### 10.3.3 组件重叠计算
```python
def _calculate_component_overlap(self, comp1, comp2):
    """计算两个组件之间的重叠面积"""
    pos1 = comp1.get_pos()
    size1 = comp1.get_size()
    pos2 = comp2.get_pos()
    size2 = comp2.get_size()
    
    # 计算重叠区域
    overlap_x = max(0, min(pos1[0] + size1[0], pos2[0] + size2[0]) - max(pos1[0], pos2[0]))
    overlap_y = max(0, min(pos1[1] + size1[1], pos2[1] + size2[1]) - max(pos1[1], pos2[1]))
    
    overlap_area = overlap_x * overlap_y
    return overlap_area
```

#### 10.3.4 HPWL计算
```python
def _calculate_hpwl_score(self, env):
    """计算HPWL（Half-Perimeter Wirelength）分数"""
    hpwl_score = 0.0
    
    # 按网络分组计算HPWL
    nets = {}
    for edge in env.g.get_edges():
        net_id = edge.get_net_id()
        if net_id not in nets:
            nets[net_id] = []
        
        node1_id = edge.get_instance_id(0)
        node2_id = edge.get_instance_id(1)
        nets[net_id].extend([node1_id, node2_id])
    
    # 计算每个网络的HPWL
    for net_id, node_ids in nets.items():
        unique_nodes = list(set(node_ids))
        positions = []
        
        for node_id in unique_nodes:
            node = env.g.get_node_by_id(node_id)
            positions.append(node.get_pos())
        
        if len(positions) > 1:
            x_coords = [pos[0] for pos in positions]
            y_coords = [pos[1] for pos in positions]
            
            hpwl = (max(x_coords) - min(x_coords)) + (max(y_coords) - min(y_coords))
            hpwl_score += hpwl
    
    return hpwl_score
```

### 10.4 总体统计计算

#### 10.4.1 统计指标计算
```python
def _calculate_overall_stats(self, evaluation_stats):
    """计算总体统计指标"""
    rewards = evaluation_stats['total_rewards']
    lengths = evaluation_stats['episode_lengths']
    wirelengths = evaluation_stats['wirelengths']
    overlaps = evaluation_stats['overlaps']
    hpwl_scores = evaluation_stats['hpwl_scores']
    
    overall_stats = {
        'mean_reward': np.mean(rewards),
        'std_reward': np.std(rewards),
        'min_reward': np.min(rewards),
        'max_reward': np.max(rewards),
        
        'mean_length': np.mean(lengths),
        'std_length': np.std(lengths),
        
        'mean_wirelength': np.mean(wirelengths),
        'std_wirelength': np.std(wirelengths),
        'min_wirelength': np.min(wirelengths),
        'max_wirelength': np.max(wirelengths),
        
        'mean_overlap': np.mean(overlaps),
        'std_overlap': np.std(overlaps),
        'total_overlap': np.sum(overlaps),
        
        'mean_hpwl': np.mean(hpwl_scores),
        'std_hpwl': np.std(hpwl_scores),
        'min_hpwl': np.min(hpwl_scores),
        'max_hpwl': np.max(hpwl_scores),
        
        'num_episodes': len(rewards),
        'success_rate': self._calculate_success_rate(evaluation_stats)
    }
    
    return overall_stats
```

#### 10.4.2 成功率计算
```python
def _calculate_success_rate(self, evaluation_stats):
    """计算成功率"""
    success_count = 0
    total_count = len(evaluation_stats['episodes'])
    
    for episode in evaluation_stats['episodes']:
        # 定义成功条件：重叠面积小于阈值且线长合理
        if (episode['overlap'] < 1.0 and  # 重叠面积小于1mm²
            episode['wirelength'] < 1000.0):  # 线长小于1000mm
            success_count += 1
    
    success_rate = success_count / total_count
    return success_rate
```

### 10.5 评估报告生成

#### 10.5.1 报告生成函数
```python
def generate_evaluation_report(self, evaluation_stats, overall_stats, output_path):
    """生成评估报告"""
    report = {
        'evaluation_summary': {
            'total_episodes': overall_stats['num_episodes'],
            'mean_reward': overall_stats['mean_reward'],
            'std_reward': overall_stats['std_reward'],
            'success_rate': overall_stats['success_rate'],
            'mean_wirelength': overall_stats['mean_wirelength'],
            'mean_overlap': overall_stats['mean_overlap'],
            'mean_hpwl': overall_stats['mean_hpwl']
        },
        'detailed_results': evaluation_stats,
        'overall_statistics': overall_stats,
        'timestamp': time.time()
    }
    
    # 保存报告
    with open(output_path, 'w') as f:
        json.dump(report, f, indent=2)
    
    print(f"Evaluation report saved: {output_path}")
    return report
```

#### 10.5.2 可视化生成
```python
def generate_evaluation_visualizations(self, evaluation_stats, output_dir):
    """生成评估可视化"""
    # 创建输出目录
    if not os.path.exists(output_dir):
        os.makedirs(output_dir)
    
    # 1. 奖励分布图
    self._plot_reward_distribution(evaluation_stats, output_dir)
    
    # 2. 线长分布图
    self._plot_wirelength_distribution(evaluation_stats, output_dir)
    
    # 3. 重叠分布图
    self._plot_overlap_distribution(evaluation_stats, output_dir)
    
    # 4. HPWL分布图
    self._plot_hpwl_distribution(evaluation_stats, output_dir)
    
    # 5. 组件位置热力图
    self._plot_component_positions(evaluation_stats, output_dir)
```

### 10.6 可视化函数

#### 10.6.1 奖励分布图
```python
def _plot_reward_distribution(self, evaluation_stats, output_dir):
    """绘制奖励分布图"""
    rewards = evaluation_stats['total_rewards']
    
    plt.figure(figsize=(10, 6))
    plt.hist(rewards, bins=20, alpha=0.7, color='blue', edgecolor='black')
    plt.xlabel('Total Reward')
    plt.ylabel('Frequency')
    plt.title('Distribution of Episode Rewards')
    plt.grid(True, alpha=0.3)
    
    # 添加统计信息
    mean_reward = np.mean(rewards)
    std_reward = np.std(rewards)
    plt.axvline(mean_reward, color='red', linestyle='--', label=f'Mean: {mean_reward:.3f}')
    plt.legend()
    
    plt.savefig(os.path.join(output_dir, 'reward_distribution.png'), dpi=300, bbox_inches='tight')
    plt.close()
```

#### 10.6.2 线长分布图
```python
def _plot_wirelength_distribution(self, evaluation_stats, output_dir):
    """绘制线长分布图"""
    wirelengths = evaluation_stats['wirelengths']
    
    plt.figure(figsize=(10, 6))
    plt.hist(wirelengths, bins=20, alpha=0.7, color='green', edgecolor='black')
    plt.xlabel('Total Wirelength (mm)')
    plt.ylabel('Frequency')
    plt.title('Distribution of Total Wirelength')
    plt.grid(True, alpha=0.3)
    
    mean_wirelength = np.mean(wirelengths)
    plt.axvline(mean_wirelength, color='red', linestyle='--', label=f'Mean: {mean_wirelength:.2f}')
    plt.legend()
    
    plt.savefig(os.path.join(output_dir, 'wirelength_distribution.png'), dpi=300, bbox_inches='tight')
    plt.close()
```

### 10.7 最佳结果保存

#### 10.7.1 最佳布局保存
```python
def save_best_layout(self, evaluation_stats, output_dir):
    """保存最佳布局结果"""
    # 找到最佳episode（奖励最高）
    best_episode_idx = np.argmax(evaluation_stats['total_rewards'])
    best_episode = evaluation_stats['episodes'][best_episode_idx]
    
    # 保存最佳布局的PCB文件
    best_pcb_path = os.path.join(output_dir, 'best_layout.pcb')
    self._save_pcb_from_positions(best_episode['final_positions'], best_pcb_path)
    
    # 保存最佳布局的图片
    best_image_path = os.path.join(output_dir, 'best_layout.png')
    self._save_layout_image(best_episode['final_positions'], best_image_path)
    
    print(f"Best layout saved: {best_pcb_path}")
    print(f"Best layout image saved: {best_image_path}")
    
    return best_episode
```

## 关键数据结构

### EvaluationStats类
- **功能**：评估统计信息
- **包含**：episode结果、奖励、线长、重叠等

### OverallStats类
- **功能**：总体统计指标
- **包含**：均值、标准差、最值、成功率等

### EpisodeResult类
- **功能**：单个episode结果
- **包含**：奖励、长度、位置、指标等

## 输出信息
```
[INFO] Starting evaluation phase with 16 episodes...
[INFO] Episode 0: Reward=-0.234, Length=45, Wirelength=156.78, HPWL=89.45
[INFO] Episode 1: Reward=-0.187, Length=42, Wirelength=142.33, HPWL=76.21
[INFO] Episode 2: Reward=-0.156, Length=38, Wirelength=138.92, HPWL=72.18
[INFO] Evaluation completed. Mean reward: -0.189
[INFO] Success rate: 75.0%
[INFO] Mean wirelength: 145.67 mm
[INFO] Mean HPWL: 79.28
[INFO] Best layout saved: /path/to/evaluation/best_layout.pcb
```

## 下一步
进入[11_报告生成阶段](./11_报告生成阶段.md) 